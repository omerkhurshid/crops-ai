// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [postgis]
}

enum UserRole {
  FARM_OWNER
  FARM_MANAGER
  AGRONOMIST
  ADMIN
}

enum UserType {
  CROPS
  LIVESTOCK
  ORCHARD
  MIXED // For users with multiple interests
}

enum CropStatus {
  PLANNED
  PLANTED
  GROWING
  READY_TO_HARVEST
  HARVESTED
  FAILED
}

enum StressLevel {
  NONE
  LOW
  MODERATE
  HIGH
  SEVERE
}

enum TransactionType {
  INCOME
  EXPENSE
}

enum FinancialCategory {
  // Income categories
  CROP_SALES
  LIVESTOCK_SALES
  SUBSIDIES
  LEASE_INCOME
  OTHER_INCOME
  HARVEST
  // Expense categories
  SEEDS
  FERTILIZER
  PESTICIDES
  LABOR
  MACHINERY
  FUEL
  IRRIGATION
  STORAGE
  INSURANCE
  OVERHEAD
  OTHER_EXPENSE
  LIVESTOCK
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  passwordHash  String?
  emailVerified DateTime?
  role          UserRole  @default(FARM_OWNER)
  userType      UserType? // Optional farming interest/type
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // User Preferences
  currency         String? @default("USD")
  landUnit         String? @default("hectares") // hectares, acres, square_meters
  temperatureUnit  String? @default("celsius")  // celsius, fahrenheit
  timezone         String? @default("UTC")
  language         String? @default("en")

  // Relations
  ownedFarms            Farm[]
  managedFarms          FarmManager[]
  weatherAlerts         WeatherAlert[]
  financialTransactions FinancialTransaction[]
  createdTransactions   FinancialTransaction[] @relation("TransactionCreator")
  verificationTokens    VerificationToken[]
  harvestRecords        HarvestRecord[]
  livestockEvents       LivestockEvent[]
  tasks                 Task[]
  decisionRecommendations DecisionRecommendation[]
  decisionExecutions    DecisionExecution[]

  @@map("users")
}

model Farm {
  id        String   @id @default(cuid())
  name      String
  ownerId   String
  location  String?  // Added to match database
  latitude  Float
  longitude Float
  address   String?
  region    String?
  country   String   @default("US")
  totalArea Float // in hectares
  boundary  Unsupported("geography")? // PostGIS geography type for farm boundaries
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner                 User                   @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  fields                Field[]
  managers              FarmManager[]
  financialTransactions FinancialTransaction[]
  financialBudgets      FinancialBudget[]
  financialForecasts    FinancialForecast[]
  harvestRecords        HarvestRecord[]
  livestockEvents       LivestockEvent[]
  tasks                 Task[]
  decisionRecommendations DecisionRecommendation[]
  decisionExecutions    DecisionExecution[]
  weatherAlerts         WeatherAlert[] @relation("FarmWeatherAlerts")
  farmRecommendations   Recommendation[] @relation("FarmRecommendations")

  @@map("farms")
}

model FarmManager {
  id     String @id @default(cuid())
  farmId String
  userId String

  // Relations
  farm Farm @relation(fields: [farmId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([farmId, userId])
  @@map("farm_managers")
}

model Field {
  id          String                     @id @default(cuid())
  farmId      String
  name        String
  area        Float // in hectares
  boundary    Unsupported("geography")? // PostGIS geography type
  soilType    String?
  color       String?                   // Hex color code for field visualization
  cropType    String?                   // Current crop type
  status      String?                   // Field status (active, fallow, etc.)
  isActive    Boolean                   @default(true) // Fields are active by default
  createdAt   DateTime                   @default(now())
  updatedAt   DateTime                   @updatedAt

  // Relations
  farm                  Farm                   @relation(fields: [farmId], references: [id], onDelete: Cascade)
  crops                 Crop[]
  satelliteData         SatelliteData[]
  weatherData           WeatherData[]
  recommendations       Recommendation[]
  financialTransactions FinancialTransaction[]
  financialForecasts    FinancialForecast[]
  tasks                 Task[]
  
  // New analytics relations
  satelliteAnalytics    SatelliteAnalytics[]
  soilAnalyses          SoilAnalysis[]
  weatherComprehensive  WeatherComprehensive[]
  analyticsPredictions  AnalyticsPrediction[]
  soilReadings          SoilReading[]

  @@map("fields")
}

model Crop {
  id                  String     @id @default(cuid())
  fieldId             String
  cropType            String
  variety             String?
  plantingDate        DateTime
  expectedHarvestDate DateTime
  actualHarvestDate   DateTime?
  status              CropStatus @default(PLANNED)
  yield               Float? // in kg/hectare
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  // Relations
  field                 Field                  @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  financialTransactions FinancialTransaction[]
  financialForecasts    FinancialForecast[]
  tasks                 Task[]

  @@map("crops")
}

model WeatherData {
  id           String   @id @default(cuid())
  fieldId      String
  timestamp    DateTime
  temperature  Float // in Celsius
  humidity     Float // percentage
  precipitation Float // in mm
  windSpeed    Float // in m/s
  windDirection Int // in degrees
  pressure     Float // in hPa
  cloudCover   Float // percentage
  createdAt    DateTime @default(now())

  // Relations
  field Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@map("weather_data")
}

model WeatherForecast {
  id                       String   @id @default(cuid())
  latitude                 Float
  longitude                Float
  date                     DateTime
  minTemp                  Float
  maxTemp                  Float
  precipitationProbability Float
  precipitationAmount      Float?
  conditions               String
  createdAt                DateTime @default(now())

  @@map("weather_forecasts")
}


model SatelliteData {
  id          String      @id @default(cuid())
  fieldId     String
  captureDate DateTime
  ndvi        Float
  ndviChange  Float?
  stressLevel StressLevel @default(NONE)
  imageUrl    String?
  createdAt   DateTime    @default(now())

  // Relations
  field Field @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@map("satellite_data")
}


model FinancialTransaction {
  id              String            @id @default(cuid())
  userId          String
  farmId          String
  fieldId         String?
  cropId          String?
  
  type            TransactionType
  category        FinancialCategory
  subcategory     String?
  
  amount          Decimal           @db.Decimal(12, 2)
  currency        String            @default("USD")
  quantity        Decimal?          @db.Decimal(10, 2)
  unitPrice       Decimal?          @db.Decimal(10, 2)
  
  transactionDate DateTime          @db.Date
  paymentDate     DateTime?         @db.Date
  
  operationId     String?
  marketPriceId   String?
  
  notes           String?           @db.Text
  attachments     Json?
  tags            String[]
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  createdById     String
  
  // Relations
  user            User              @relation(fields: [userId], references: [id])
  farm            Farm              @relation(fields: [farmId], references: [id])
  field           Field?            @relation(fields: [fieldId], references: [id])
  crop            Crop?             @relation(fields: [cropId], references: [id])
  marketPrice     MarketPrice?      @relation(fields: [marketPriceId], references: [id])
  createdBy       User              @relation("TransactionCreator", fields: [createdById], references: [id])
  
  @@index([farmId, transactionDate])
  @@index([type, category])
  @@index([fieldId])
  @@map("financial_transactions")
}

model FinancialBudget {
  id            String   @id @default(cuid())
  farmId        String
  seasonId      String?
  year          Int
  month         Int?
  
  category      FinancialCategory
  plannedAmount Decimal  @db.Decimal(12, 2)
  actualAmount  Decimal  @default(0) @db.Decimal(12, 2)
  currency      String   @default("USD")
  
  notes         String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  farm          Farm     @relation(fields: [farmId], references: [id])
  
  @@unique([farmId, year, month, category])
  @@index([farmId, year])
  @@map("financial_budgets")
}

model FinancialForecast {
  id               String   @id @default(cuid())
  farmId           String
  fieldId          String?
  cropId           String?
  
  forecastDate     DateTime @db.Date
  forecastType     String   // yield, price, revenue, cost
  predictedYield   Decimal? @db.Decimal(10, 2)
  predictedPrice   Decimal? @db.Decimal(10, 2)
  predictedRevenue Decimal? @db.Decimal(12, 2)
  predictedCost    Decimal? @db.Decimal(12, 2)
  confidenceScore  Decimal  @db.Decimal(5, 2)
  
  modelId          String?
  modelVersion     String?
  assumptions      Json?
  
  createdAt        DateTime @default(now())
  
  // Relations
  farm             Farm     @relation(fields: [farmId], references: [id])
  field            Field?   @relation(fields: [fieldId], references: [id])
  crop             Crop?    @relation(fields: [cropId], references: [id])
  
  @@index([farmId, forecastDate])
  @@map("financial_forecasts")
}

model MarketPrice {
  id        String   @id @default(cuid())
  commodity String
  market    String
  price     Float
  currency  String   @default("USD")
  unit      String // bushel, ton, kg, etc.
  date      DateTime
  createdAt DateTime @default(now())

  // Relations
  financialTransactions FinancialTransaction[]

  @@index([commodity, date])
  @@map("market_prices")
}

model VerificationToken {
  identifier String   // email
  token      String   @unique
  expires    DateTime
  type       String   // 'email-verify' | 'password-reset'
  userId     String?
  user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  
  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ==================== CROP/PRODUCE DATABASE ====================

enum ProduceCategory {
  CROPS       // Grains, cereals (corn, wheat, rice)
  VEGETABLES  // Edible plants (tomato, carrot, lettuce)
  FRUITS      // Tree and vine fruits (apple, grape, strawberry)
  TREES       // Non-fruit trees (oak, pine, maple)
  HERBS       // Culinary and medicinal herbs
  NUTS        // Tree nuts and ground nuts
}

enum ClimateZone {
  TROPICAL
  SUBTROPICAL
  TEMPERATE
  CONTINENTAL
  POLAR
  ARID
  MEDITERRANEAN
}

enum SoilType {
  CLAY
  SANDY
  LOAM
  SILT
  PEAT
  CHALK
  SANDY_LOAM
  CLAY_LOAM
  SILT_LOAM
}

enum WaterRequirement {
  VERY_LOW   // Drought tolerant
  LOW        // Minimal water
  MODERATE   // Regular watering
  HIGH       // Frequent watering
  VERY_HIGH  // Constant moisture
}

enum SunRequirement {
  FULL_SHADE
  PARTIAL_SHADE
  PARTIAL_SUN
  FULL_SUN
}

enum GrowthHabit {
  ANNUAL      // Complete lifecycle in one year
  BIENNIAL    // Two-year lifecycle
  PERENNIAL   // Lives for multiple years
  DECIDUOUS   // Loses leaves seasonally
  EVERGREEN   // Retains leaves year-round
}

model ProduceType {
  id                String           @id @default(cuid())
  name              String           @unique
  scientificName    String
  category          ProduceCategory
  description       String?
  
  // Growing Requirements
  climateZones      ClimateZone[]
  hardinessZoneMin  Int?            // USDA Hardiness Zone minimum
  hardinessZoneMax  Int?            // USDA Hardiness Zone maximum
  soilTypes         SoilType[]
  soilPhMin         Float?          // Minimum soil pH
  soilPhMax         Float?          // Maximum soil pH
  waterRequirement  WaterRequirement
  sunRequirement    SunRequirement
  growthHabit       GrowthHabit
  
  // Planting Information
  plantingDepth     Float?          // in inches
  plantSpacing      Float?          // in inches
  rowSpacing        Float?          // in inches
  germinationDays   Int?            // Days to germination
  daysToMaturity    Int?            // Days from planting to harvest
  
  // Physical Characteristics
  matureHeight      Float?          // in feet
  matureSpread      Float?          // in feet
  
  // Additional Information
  companionPlants   String[]        // Good companion plants
  incompatibleWith  String[]        // Plants to avoid nearby
  commonPests       String[]        // Common pest threats
  commonDiseases    String[]        // Common disease threats
  
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  
  // Relations
  varieties         ProduceVariety[]
  nutritionalData   NutritionalData?
  
  @@map("produce_types")
}

model ProduceVariety {
  id                String      @id @default(cuid())
  produceTypeId     String
  name              String
  description       String?
  
  // Variety-specific characteristics
  daysToMaturity    Int?        // May differ from parent type
  yieldPerPlant     Float?      // Average yield in appropriate units
  yieldUnit         String?     // kg, lbs, bushels, etc.
  
  // Market Information
  marketDemand      String?     // High, Medium, Low
  premiumVariety    Boolean     @default(false)
  
  // Growing Characteristics
  diseaseResistance String[]    // List of diseases this variety resists
  droughtTolerant   Boolean     @default(false)
  coldTolerant      Boolean     @default(false)
  heatTolerant      Boolean     @default(false)
  
  // Appearance
  color             String?
  size              String?     // Small, Medium, Large, etc.
  shape             String?
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  // Relations
  produceType       ProduceType @relation(fields: [produceTypeId], references: [id], onDelete: Cascade)
  
  @@map("produce_varieties")
}

model NutritionalData {
  id              String      @id @default(cuid())
  produceTypeId   String      @unique
  
  // Per 100g serving
  calories        Float?
  protein         Float?      // grams
  carbohydrates   Float?      // grams
  fiber           Float?      // grams
  sugar           Float?      // grams
  fat             Float?      // grams
  saturatedFat    Float?      // grams
  
  // Vitamins (% Daily Value)
  vitaminA        Float?
  vitaminC        Float?
  vitaminD        Float?
  vitaminE        Float?
  vitaminK        Float?
  vitaminB6       Float?
  vitaminB12      Float?
  
  // Minerals (mg unless specified)
  calcium         Float?
  iron            Float?
  magnesium       Float?
  phosphorus      Float?
  potassium       Float?
  sodium          Float?
  zinc            Float?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Relations
  produceType     ProduceType @relation(fields: [produceTypeId], references: [id], onDelete: Cascade)
  
  @@map("nutritional_data")
}

model PlantingCalendar {
  id              String      @id @default(cuid())
  produceTypeId   String
  region          String      // Geographic region
  
  // Planting windows (month numbers 1-12)
  springPlantStart Int?
  springPlantEnd   Int?
  fallPlantStart   Int?
  fallPlantEnd     Int?
  
  // Harvest windows
  harvestStart     Int?
  harvestEnd       Int?
  
  // Indoor starting
  indoorStartWeeks Int?       // Weeks before last frost to start indoors
  
  notes           String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@map("planting_calendars")
}

model HarvestRecord {
  id           String   @id @default(cuid())
  farmId       String
  fieldName    String
  cropType     String
  quantity     Float
  unit         String   @default("tons")
  qualityNotes String?
  harvestDate  DateTime @default(now())
  userId       String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  // Relations
  farm         Farm     @relation(fields: [farmId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("harvest_records")
}

model LivestockEvent {
  id            String   @id @default(cuid())
  farmId        String
  livestockType String   // cattle, sheep, goats, etc.
  eventType     String   // vaccination, breeding, calving, etc.
  animalCount   Int
  notes         String?
  eventDate     DateTime @default(now())
  userId        String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  farm          Farm     @relation(fields: [farmId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("livestock_events")
}

model Task {
  id          String    @id @default(cuid())
  farmId      String
  fieldId     String?
  cropId      String?
  userId      String
  
  title       String
  description String?   @db.Text
  status      String    @default("pending") // pending, in_progress, completed, cancelled
  priority    String    @default("medium") // low, medium, high, urgent
  
  dueDate     DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Task categorization
  category    String?   // planting, harvesting, maintenance, etc.
  tags        String[]  // for flexible categorization
  
  // Relations
  farm        Farm      @relation(fields: [farmId], references: [id], onDelete: Cascade)
  field       Field?    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  crop        Crop?     @relation(fields: [cropId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([farmId, status])
  @@index([userId, status])
  @@index([dueDate])
  @@map("tasks")
}

model DecisionRecommendation {
  id          String   @id @default(cuid())
  userId      String
  farmId      String
  type        String   // SPRAY, HARVEST, IRRIGATE, etc.
  priority    String   // URGENT, HIGH, MEDIUM, LOW
  title       String
  description String
  
  // Decision scoring
  urgencyScore     Int
  roiScore        Int
  feasibilityScore Int
  totalScore      Int
  confidence      Int
  
  // Timing
  idealStart      DateTime?
  idealEnd        DateTime?
  mustCompleteBy  DateTime?
  
  // Financial impact
  estimatedRevenue    Float?
  estimatedCostSaving Float?
  estimatedYieldGain  Float? // percentage
  
  // Requirements
  weatherRequirements Json? // weather constraints
  resourceRequirements String[] // required resources
  
  // Decision details
  explanation     String
  actionSteps     String[]
  alternatives    String[]
  
  // Status tracking
  status          String   @default("PENDING") // PENDING, ACCEPTED, REJECTED, COMPLETED
  userResponse    String? // User feedback
  actualOutcome   Json? // Track actual results
  
  // Relations
  targetField     String?
  relatedDecisions String[] // IDs of related decisions
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  completedAt     DateTime?
  
  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  farm            Farm     @relation(fields: [farmId], references: [id], onDelete: Cascade)
  
  @@map("decision_recommendations")
}

model DecisionTemplate {
  id              String   @id @default(cuid())
  name            String
  category        String
  description     String
  requiredInputs  Json     // Schema for required inputs
  decisionLogic   String   // Logic description
  bestPractices   String[]
  commonMistakes  String[]
  regulations     String[]
  isActive        Boolean  @default(true)
  version         String   @default("1.0")
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Usage tracking
  executions      DecisionExecution[]
  
  @@map("decision_templates")
}

model DecisionExecution {
  id                String   @id @default(cuid())
  templateId        String
  userId            String
  farmId            String
  inputs            Json     // User inputs
  recommendation    Json     // Generated recommendation
  userAction        String?  // What user decided to do
  actualOutcome     Json?    // Actual results
  satisfaction      Int?     // User satisfaction rating 1-5
  feedback          String?  // User feedback text
  
  executedAt        DateTime @default(now())
  completedAt       DateTime?
  
  // Relations
  template          DecisionTemplate @relation(fields: [templateId], references: [id])
  user              User             @relation(fields: [userId], references: [id])
  farm              Farm             @relation(fields: [farmId], references: [id])
  
  @@map("decision_executions")
}

model WeatherAlert {
  id            String   @id @default(cuid())
  userId        String
  farmId        String?
  alertType     String   // FROST, HAIL, WIND, DROUGHT, etc.
  severity      String   // LOW, MEDIUM, HIGH, SEVERE
  message       String
  isActive      Boolean  @default(true)
  triggeredAt   DateTime @default(now())
  expiresAt     DateTime?
  
  // Location
  latitude      Float?
  longitude     Float?
  
  // Alert data
  weatherData   Json?    // Specific weather conditions
  
  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  farm          Farm?    @relation("FarmWeatherAlerts", fields: [farmId], references: [id], onDelete: Cascade)
  
  @@map("weather_alerts")
}

// ==================== ANALYTICS & ML MODELS ====================

model SatelliteAnalytics {
  id                     String   @id @default(cuid())
  fieldId                String
  captureDate            DateTime @db.Date
  ndviAvg                Decimal? @db.Decimal(5,3)
  ndviStd                Decimal? @db.Decimal(5,3)
  ndviTrend             Decimal? @db.Decimal(5,3) // 30-day trend
  stressZones           Json?    // GeoJSON of stress areas
  biomassEstimate       Decimal? @db.Decimal(8,2)
  growthStageDetected   String?  @db.VarChar(50)
  anomalyScore          Decimal? @db.Decimal(5,3) // ML-detected anomalies
  confidenceScore       Decimal? @db.Decimal(3,2)
  createdAt             DateTime @default(now())
  
  // Relations
  field                 Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  @@map("satellite_analytics")
  @@index([fieldId, captureDate(sort: Desc)])
}

model SoilAnalysis {
  id                    String   @id @default(cuid())
  fieldId               String
  sampleDate            DateTime @db.Date
  sampleLat             Decimal? @db.Decimal(10,6)
  sampleLng             Decimal? @db.Decimal(10,6)
  phLevel               Decimal? @db.Decimal(3,1)
  nitrogenPpm           Decimal? @db.Decimal(8,2)
  phosphorusPpm         Decimal? @db.Decimal(8,2)
  potassiumPpm          Decimal? @db.Decimal(8,2)
  organicMatterPct      Decimal? @db.Decimal(5,2)
  cec                   Decimal? @db.Decimal(5,2) // Cation exchange capacity
  soilType              String?  @db.VarChar(100)
  drainageClass         String?  @db.VarChar(50)
  createdAt             DateTime @default(now())
  
  // Relations
  field                 Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  @@map("soil_analysis")
}

model WeatherComprehensive {
  id                    String   @id @default(cuid())
  fieldId               String
  recordedAt            DateTime
  temperature           Decimal? @db.Decimal(5,2)
  humidity              Decimal? @db.Decimal(5,2)
  precipitation         Decimal? @db.Decimal(6,2)
  windSpeed             Decimal? @db.Decimal(5,2)
  solarRadiation        Decimal? @db.Decimal(8,2)
  evapotranspiration    Decimal? @db.Decimal(6,2)
  growingDegreeDays     Decimal? @db.Decimal(8,2)
  stressDegreeDays      Decimal? @db.Decimal(8,2)
  soilTemperature       Decimal? @db.Decimal(5,2)
  createdAt             DateTime @default(now())
  
  // Relations
  field                 Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  @@map("weather_comprehensive")
  @@index([fieldId, recordedAt(sort: Desc)])
}

model AnalyticsPrediction {
  id                    String   @id @default(cuid())
  fieldId               String
  modelName             String   @db.VarChar(100) // 'yield_prediction', 'pest_risk', etc.
  modelVersion          String   @db.VarChar(20)
  predictionDate        DateTime @db.Date
  predictionValue       Json     // Flexible JSON for different prediction types
  confidenceScore       Decimal? @db.Decimal(3,2)
  featureImportance     Json?
  createdAt             DateTime @default(now())
  
  // Relations
  field                 Field    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  @@map("analytics_predictions")
  @@index([fieldId, modelName, predictionDate(sort: Desc)])
}

model RegionalBenchmark {
  id                    String   @id @default(cuid())
  region                String   @db.VarChar(100)
  cropType              String   @db.VarChar(100)
  metricName            String   @db.VarChar(100) // 'yield_per_acre', 'cost_per_acre', etc.
  percentile25          Decimal? @db.Decimal(10,2)
  percentile50          Decimal? @db.Decimal(10,2)
  percentile75          Decimal? @db.Decimal(10,2)
  percentile90          Decimal? @db.Decimal(10,2)
  sampleSize            Int?
  year                  Int
  updatedAt             DateTime @updatedAt
  
  @@map("regional_benchmarks")
  @@index([region, cropType, year])
}

model Recommendation {
  id                    String    @id @default(cuid())
  farmId                String?
  fieldId               String?
  recommendationType    String    @db.VarChar(100) // 'fertilizer', 'irrigation', 'pest_control', etc.
  priority              String    @db.VarChar(20) // 'low', 'medium', 'high', 'urgent'
  title                 String    @db.VarChar(200)
  description           String?   @db.Text
  actionRequired        String?   @db.Text
  potentialImpact       String?   @db.VarChar(500) // e.g., "Could increase yield by 8-12%"
  confidenceLevel       String?   @db.VarChar(20) // 'low', 'medium', 'high'
  estimatedCost         Decimal?  @db.Decimal(10,2)
  estimatedRoi          Decimal?  @db.Decimal(5,2) // ROI percentage
  optimalTiming         DateTime? @db.Date
  createdAt             DateTime  @default(now())
  expiresAt             DateTime?
  status                String    @default("active") @db.VarChar(20) // 'active', 'completed', 'dismissed', 'expired'
  
  // Relations
  farm                  Farm?     @relation("FarmRecommendations", fields: [farmId], references: [id], onDelete: Cascade)
  field                 Field?    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  @@map("recommendations")
  @@index([farmId, status, createdAt(sort: Desc)])
  @@index([fieldId, priority, optimalTiming])
}

model SoilReading {
  id                    String    @id @default(cuid())
  fieldId               String
  sensorId              String?   @db.VarChar(100)
  timestamp             DateTime  @default(now())
  depth                 Float     // cm
  temperature           Float     // Â°C
  moisture              Float     // %
  ph                    Float
  electricalConductivity Float    // dS/m
  nitrogen              Float     // ppm
  phosphorus            Float     // ppm
  potassium             Float     // ppm
  latitude              Float     @db.DoublePrecision
  longitude             Float     @db.DoublePrecision
  quality               String    @default("medium") @db.VarChar(10) // 'high', 'medium', 'low'
  
  // Relations
  field                 Field     @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  @@map("soil_readings")
  @@index([fieldId, timestamp(sort: Desc)])
  @@index([timestamp, quality])
}