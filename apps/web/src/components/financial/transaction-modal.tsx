'use client';

import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Textarea } from '@/components/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { Badge } from '@/components/ui/badge';\nimport { X, DollarSign, Calendar, Tag, FileText, AlertCircle } from 'lucide-react';\n\ninterface Field {\n  id: string;\n  name: string;\n  area: number;\n}\n\ninterface Crop {\n  id: string;\n  fieldId: string;\n  cropType: string;\n  variety?: string;\n}\n\ninterface TransactionModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  farmId: string;\n  type: 'INCOME' | 'EXPENSE';\n  onSuccess: () => void;\n  editTransaction?: any;\n}\n\nconst INCOME_CATEGORIES = [\n  { value: 'CROP_SALES', label: 'Crop Sales', icon: '🌾' },\n  { value: 'LIVESTOCK_SALES', label: 'Livestock Sales', icon: '🐄' },\n  { value: 'SUBSIDIES', label: 'Subsidies', icon: '💰' },\n  { value: 'LEASE_INCOME', label: 'Lease Income', icon: '🏡' },\n  { value: 'OTHER_INCOME', label: 'Other Income', icon: '📈' },\n];\n\nconst EXPENSE_CATEGORIES = [\n  { value: 'SEEDS', label: 'Seeds', icon: '🌱' },\n  { value: 'FERTILIZER', label: 'Fertilizer', icon: '🧪' },\n  { value: 'PESTICIDES', label: 'Pesticides', icon: '🚿' },\n  { value: 'LABOR', label: 'Labor', icon: '👨‍🌾' },\n  { value: 'MACHINERY', label: 'Machinery', icon: '🚜' },\n  { value: 'FUEL', label: 'Fuel', icon: '⛽' },\n  { value: 'IRRIGATION', label: 'Irrigation', icon: '💧' },\n  { value: 'STORAGE', label: 'Storage', icon: '🏪' },\n  { value: 'INSURANCE', label: 'Insurance', icon: '🛡️' },\n  { value: 'OVERHEAD', label: 'Overhead', icon: '🏢' },\n  { value: 'OTHER_EXPENSE', label: 'Other Expense', icon: '📄' },\n];\n\nexport function TransactionModal({\n  isOpen,\n  onClose,\n  farmId,\n  type,\n  onSuccess,\n  editTransaction,\n}: TransactionModalProps) {\n  const [loading, setLoading] = useState(false);\n  const [fields, setFields] = useState<Field[]>([]);\n  const [crops, setCrops] = useState<Crop[]>([]);\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  \n  const [formData, setFormData] = useState({\n    type,\n    category: '',\n    subcategory: '',\n    amount: '',\n    quantity: '',\n    unitPrice: '',\n    transactionDate: new Date().toISOString().split('T')[0],\n    paymentDate: '',\n    fieldId: '',\n    cropId: '',\n    notes: '',\n    tags: [] as string[],\n  });\n\n  const [tagInput, setTagInput] = useState('');\n\n  useEffect(() => {\n    if (isOpen) {\n      fetchFields();\n      if (editTransaction) {\n        populateForm(editTransaction);\n      } else {\n        resetForm();\n      }\n    }\n  }, [isOpen, editTransaction]);\n\n  useEffect(() => {\n    if (formData.fieldId) {\n      fetchCrops(formData.fieldId);\n    }\n  }, [formData.fieldId]);\n\n  useEffect(() => {\n    // Auto-calculate amount if quantity and unit price are provided\n    if (formData.quantity && formData.unitPrice) {\n      const calculatedAmount = parseFloat(formData.quantity) * parseFloat(formData.unitPrice);\n      setFormData(prev => ({ ...prev, amount: calculatedAmount.toFixed(2) }));\n    }\n  }, [formData.quantity, formData.unitPrice]);\n\n  const resetForm = () => {\n    setFormData({\n      type,\n      category: '',\n      subcategory: '',\n      amount: '',\n      quantity: '',\n      unitPrice: '',\n      transactionDate: new Date().toISOString().split('T')[0],\n      paymentDate: '',\n      fieldId: '',\n      cropId: '',\n      notes: '',\n      tags: [],\n    });\n    setTagInput('');\n    setErrors({});\n  };\n\n  const populateForm = (transaction: any) => {\n    setFormData({\n      type: transaction.type,\n      category: transaction.category,\n      subcategory: transaction.subcategory || '',\n      amount: transaction.amount.toString(),\n      quantity: transaction.quantity?.toString() || '',\n      unitPrice: transaction.unitPrice?.toString() || '',\n      transactionDate: transaction.transactionDate.split('T')[0],\n      paymentDate: transaction.paymentDate?.split('T')[0] || '',\n      fieldId: transaction.fieldId || '',\n      cropId: transaction.cropId || '',\n      notes: transaction.notes || '',\n      tags: transaction.tags || [],\n    });\n  };\n\n  const fetchFields = async () => {\n    try {\n      const response = await fetch(`/api/fields?farmId=${farmId}`);\n      if (response.ok) {\n        const data = await response.json();\n        setFields(data.fields || []);\n      }\n    } catch (error) {\n      console.error('Error fetching fields:', error);\n    }\n  };\n\n  const fetchCrops = async (fieldId: string) => {\n    try {\n      const response = await fetch(`/api/crops?fieldId=${fieldId}`);\n      if (response.ok) {\n        const data = await response.json();\n        setCrops(data.crops || []);\n      }\n    } catch (error) {\n      console.error('Error fetching crops:', error);\n    }\n  };\n\n  const validateForm = () => {\n    const newErrors: Record<string, string> = {};\n\n    if (!formData.category) {\n      newErrors.category = 'Category is required';\n    }\n\n    if (!formData.amount || parseFloat(formData.amount) <= 0) {\n      newErrors.amount = 'Valid amount is required';\n    }\n\n    if (!formData.transactionDate) {\n      newErrors.transactionDate = 'Transaction date is required';\n    }\n\n    if (formData.quantity && (!formData.unitPrice || parseFloat(formData.unitPrice) <= 0)) {\n      newErrors.unitPrice = 'Unit price is required when quantity is specified';\n    }\n\n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!validateForm()) {\n      return;\n    }\n\n    setLoading(true);\n    \n    try {\n      const payload = {\n        farmId,\n        ...formData,\n        amount: parseFloat(formData.amount),\n        quantity: formData.quantity ? parseFloat(formData.quantity) : undefined,\n        unitPrice: formData.unitPrice ? parseFloat(formData.unitPrice) : undefined,\n        transactionDate: new Date(formData.transactionDate).toISOString(),\n        paymentDate: formData.paymentDate ? new Date(formData.paymentDate).toISOString() : undefined,\n        fieldId: formData.fieldId || undefined,\n        cropId: formData.cropId || undefined,\n      };\n\n      const url = editTransaction\n        ? `/api/financial/transactions/${editTransaction.id}`\n        : '/api/financial/transactions';\n      \n      const method = editTransaction ? 'PUT' : 'POST';\n\n      const response = await fetch(url, {\n        method,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      });\n\n      if (response.ok) {\n        onSuccess();\n        onClose();\n      } else {\n        const errorData = await response.json();\n        if (errorData.details) {\n          const fieldErrors: Record<string, string> = {};\n          errorData.details.forEach((error: any) => {\n            fieldErrors[error.path[0]] = error.message;\n          });\n          setErrors(fieldErrors);\n        } else {\n          setErrors({ general: errorData.error || 'Failed to save transaction' });\n        }\n      }\n    } catch (error) {\n      console.error('Error saving transaction:', error);\n      setErrors({ general: 'Failed to save transaction' });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleAddTag = () => {\n    if (tagInput.trim() && !formData.tags.includes(tagInput.trim())) {\n      setFormData(prev => ({\n        ...prev,\n        tags: [...prev.tags, tagInput.trim()]\n      }));\n      setTagInput('');\n    }\n  };\n\n  const handleRemoveTag = (tagToRemove: string) => {\n    setFormData(prev => ({\n      ...prev,\n      tags: prev.tags.filter(tag => tag !== tagToRemove)\n    }));\n  };\n\n  const categories = type === 'INCOME' ? INCOME_CATEGORIES : EXPENSE_CATEGORIES;\n  const selectedCategory = categories.find(cat => cat.value === formData.category);\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent className=\"max-w-2xl max-h-[90vh] overflow-y-auto\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center space-x-2\">\n            <div className={`p-2 rounded-full ${\n              type === 'INCOME' ? 'bg-green-100 text-green-600' : 'bg-red-100 text-red-600'\n            }`}>\n              <DollarSign className=\"h-5 w-5\" />\n            </div>\n            <span>\n              {editTransaction ? 'Edit' : 'Add'} {type === 'INCOME' ? 'Income' : 'Expense'}\n            </span>\n          </DialogTitle>\n        </DialogHeader>\n\n        <form onSubmit={handleSubmit} className=\"space-y-6\">\n          {errors.general && (\n            <div className=\"flex items-center space-x-2 p-3 bg-red-50 border border-red-200 rounded-lg\">\n              <AlertCircle className=\"h-5 w-5 text-red-500\" />\n              <span className=\"text-red-700\">{errors.general}</span>\n            </div>\n          )}\n\n          {/* Category Selection */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"category\">Category *</Label>\n            <Select\n              value={formData.category}\n              onValueChange={(value) => setFormData(prev => ({ ...prev, category: value }))}\n            >\n              <SelectTrigger className={errors.category ? 'border-red-500' : ''}>\n                <SelectValue placeholder=\"Select category\">\n                  {selectedCategory && (\n                    <div className=\"flex items-center space-x-2\">\n                      <span>{selectedCategory.icon}</span>\n                      <span>{selectedCategory.label}</span>\n                    </div>\n                  )}\n                </SelectValue>\n              </SelectTrigger>\n              <SelectContent>\n                {categories.map(category => (\n                  <SelectItem key={category.value} value={category.value}>\n                    <div className=\"flex items-center space-x-2\">\n                      <span>{category.icon}</span>\n                      <span>{category.label}</span>\n                    </div>\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n            {errors.category && <p className=\"text-sm text-red-500\">{errors.category}</p>}\n          </div>\n\n          {/* Subcategory */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"subcategory\">Subcategory</Label>\n            <Input\n              id=\"subcategory\"\n              value={formData.subcategory}\n              onChange={(e) => setFormData(prev => ({ ...prev, subcategory: e.target.value }))}\n              placeholder=\"Optional subcategory\"\n            />\n          </div>\n\n          {/* Amount, Quantity, Unit Price */}\n          <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"amount\">Amount ($) *</Label>\n              <Input\n                id=\"amount\"\n                type=\"number\"\n                step=\"0.01\"\n                min=\"0\"\n                value={formData.amount}\n                onChange={(e) => setFormData(prev => ({ ...prev, amount: e.target.value }))}\n                className={errors.amount ? 'border-red-500' : ''}\n                placeholder=\"0.00\"\n              />\n              {errors.amount && <p className=\"text-sm text-red-500\">{errors.amount}</p>}\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"quantity\">Quantity</Label>\n              <Input\n                id=\"quantity\"\n                type=\"number\"\n                step=\"0.01\"\n                min=\"0\"\n                value={formData.quantity}\n                onChange={(e) => setFormData(prev => ({ ...prev, quantity: e.target.value }))}\n                placeholder=\"Optional\"\n              />\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"unitPrice\">Unit Price ($)</Label>\n              <Input\n                id=\"unitPrice\"\n                type=\"number\"\n                step=\"0.01\"\n                min=\"0\"\n                value={formData.unitPrice}\n                onChange={(e) => setFormData(prev => ({ ...prev, unitPrice: e.target.value }))}\n                className={errors.unitPrice ? 'border-red-500' : ''}\n                placeholder=\"0.00\"\n              />\n              {errors.unitPrice && <p className=\"text-sm text-red-500\">{errors.unitPrice}</p>}\n            </div>\n          </div>\n\n          {/* Dates */}\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"transactionDate\">Transaction Date *</Label>\n              <Input\n                id=\"transactionDate\"\n                type=\"date\"\n                value={formData.transactionDate}\n                onChange={(e) => setFormData(prev => ({ ...prev, transactionDate: e.target.value }))}\n                className={errors.transactionDate ? 'border-red-500' : ''}\n              />\n              {errors.transactionDate && <p className=\"text-sm text-red-500\">{errors.transactionDate}</p>}\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"paymentDate\">Payment Date</Label>\n              <Input\n                id=\"paymentDate\"\n                type=\"date\"\n                value={formData.paymentDate}\n                onChange={(e) => setFormData(prev => ({ ...prev, paymentDate: e.target.value }))}\n                placeholder=\"Optional\"\n              />\n            </div>\n          </div>\n\n          {/* Field and Crop Selection */}\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"field\">Field</Label>\n              <Select\n                value={formData.fieldId}\n                onValueChange={(value) => setFormData(prev => ({ ...prev, fieldId: value, cropId: '' }))}\n              >\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select field (optional)\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {fields.map(field => (\n                    <SelectItem key={field.id} value={field.id}>\n                      {field.name} ({field.area.toFixed(1)} ha)\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"crop\">Crop</Label>\n              <Select\n                value={formData.cropId}\n                onValueChange={(value) => setFormData(prev => ({ ...prev, cropId: value }))}\n                disabled={!formData.fieldId}\n              >\n                <SelectTrigger>\n                  <SelectValue placeholder=\"Select crop (optional)\" />\n                </SelectTrigger>\n                <SelectContent>\n                  {crops.map(crop => (\n                    <SelectItem key={crop.id} value={crop.id}>\n                      {crop.cropType} {crop.variety && `(${crop.variety})`}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n\n          {/* Notes */}\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"notes\">Notes</Label>\n            <Textarea\n              id=\"notes\"\n              value={formData.notes}\n              onChange={(e) => setFormData(prev => ({ ...prev, notes: e.target.value }))}\n              placeholder=\"Optional notes...\"\n              rows={3}\n            />\n          </div>\n\n          {/* Tags */}\n          <div className=\"space-y-2\">\n            <Label>Tags</Label>\n            <div className=\"flex flex-wrap gap-2 mb-2\">\n              {formData.tags.map(tag => (\n                <Badge key={tag} variant=\"secondary\" className=\"flex items-center space-x-1\">\n                  <span>{tag}</span>\n                  <X\n                    className=\"h-3 w-3 cursor-pointer\"\n                    onClick={() => handleRemoveTag(tag)}\n                  />\n                </Badge>\n              ))}\n            </div>\n            <div className=\"flex space-x-2\">\n              <Input\n                value={tagInput}\n                onChange={(e) => setTagInput(e.target.value)}\n                placeholder=\"Add tag...\"\n                onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}\n              />\n              <Button type=\"button\" variant=\"outline\" onClick={handleAddTag}>\n                <Tag className=\"h-4 w-4\" />\n              </Button>\n            </div>\n          </div>\n\n          {/* Actions */}\n          <div className=\"flex justify-end space-x-3 pt-4 border-t\">\n            <Button type=\"button\" variant=\"outline\" onClick={onClose} disabled={loading}>\n              Cancel\n            </Button>\n            <Button\n              type=\"submit\"\n              disabled={loading}\n              className={type === 'INCOME' ? 'bg-green-600 hover:bg-green-700' : ''}\n            >\n              {loading ? 'Saving...' : editTransaction ? 'Update' : 'Add'} {type === 'INCOME' ? 'Income' : 'Expense'}\n            </Button>\n          </div>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}